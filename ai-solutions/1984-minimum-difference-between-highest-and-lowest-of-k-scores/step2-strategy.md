# Step 2: Strategy

## 1. Key Observations

1. **정렬의 이점**: 배열을 정렬하면, k개의 연속된 원소를 선택했을 때 그 차이(마지막 - 첫번째)가 최소가 됨
2. **연속 구간**: 정렬된 배열에서 k개를 선택할 때, 비연속적인 원소를 선택하면 차이가 더 커질 수밖에 없음
3. **슬라이딩 윈도우**: 정렬 후 크기 k의 윈도우를 슬라이딩하며 각 윈도우의 (마지막 - 첫번째) 값 중 최소를 찾으면 됨

## 2. Algorithm Choice

**Sorting + Sliding Window**

1. 배열을 오름차순으로 정렬
2. 크기 k의 윈도우를 처음부터 끝까지 슬라이딩
3. 각 윈도우에서 `nums[i + k - 1] - nums[i]` 계산
4. 모든 윈도우 중 최소값 반환

### 정당성

- 정렬된 배열에서 연속된 k개의 원소를 선택하면, 그 k개 중 최대값은 맨 오른쪽, 최소값은 맨 왼쪽
- 비연속적으로 선택하면 범위가 더 넓어지므로 차이가 커짐
- 따라서 모든 연속 구간만 검사하면 충분

## 3. Time & Space Complexity

- **Time**: O(n log n) - 정렬이 지배적
- **Space**: O(1) ~ O(n) - 정렬 알고리즘에 따라 다름 (in-place 정렬 시 O(1))

### Constraints 검증

- n <= 1000이므로 O(n log n)은 충분히 빠름
- 더 복잡한 알고리즘 불필요
