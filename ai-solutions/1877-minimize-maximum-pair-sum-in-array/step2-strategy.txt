## 1. Key Observations

- **Greedy 접근 가능**: 최대 쌍 합을 최소화하려면, 큰 수와 작은 수를 짝지어야 한다
- **정렬 후 양 끝 매칭**: 가장 큰 수 + 가장 작은 수, 두 번째로 큰 수 + 두 번째로 작은 수... 이렇게 짝지으면 쌍들의 합이 균등하게 분포됨
- **반례 검증**: 만약 큰 수끼리 짝지으면 그 쌍의 합이 매우 커지므로 최대값이 증가함
- **n이 최대 10^5**: O(n log n) 또는 O(n) 알고리즘 필요

## 2. Algorithm Choice

**Sorting + Two Pointer**

1. 배열을 오름차순 정렬
2. 왼쪽 포인터(최솟값)와 오른쪽 포인터(최댓값)를 설정
3. 양 끝에서 동시에 중앙으로 이동하며 쌍을 만듦
4. 각 쌍의 합 중 최댓값을 추적

## 3. Time & Space Complexity

| 복잡도 | 값 | 설명 |
|--------|-----|------|
| Time | O(n log n) | 정렬이 지배적 |
| Space | O(1) | 추가 공간 불필요 (in-place 정렬 시) |
