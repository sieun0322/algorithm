## 두 가지 접근법 비교

### 방식 1: Sorting + Two Pointer

```java
class Solution {
    public int minPairSum(int[] nums) {
        Arrays.sort(nums);
        int left = 0, right = nums.length - 1;
        int max = 0;
        while (left < right) {
            int sum = nums[left] + nums[right];
            if (sum > max) max = sum;
            left++;
            right--;
        }
        return max;
    }
}
```

| 항목 | 값 |
|------|-----|
| Time | O(n log n) |
| Space | O(1) |
| 장점 | 메모리 효율적, 값 범위 제한 없음 |
| 단점 | 정렬 비용 |

---

### 방식 2: Counting Sort (Frequency Array)

```java
class Solution {
    public int minPairSum(int[] nums) {
        int maxSum = Integer.MIN_VALUE;
        int minNum = Integer.MAX_VALUE;
        int maxNum = Integer.MIN_VALUE;
        int frequency[] = new int[100001];

        for (int num : nums) {
            frequency[num]++;
            minNum = Math.min(minNum, num);
            maxNum = Math.max(maxNum, num);
        }

        int low = minNum;
        int high = maxNum;

        while (low <= high) {
            if (frequency[low] == 0) {
                low++;
            } else if (frequency[high] == 0) {
                high--;
            } else {
                int currentPairSum = low + high;
                maxSum = Math.max(maxSum, currentPairSum);
                frequency[low]--;
                frequency[high]--;
            }
        }

        return maxSum;
    }
}
```

| 항목 | 값 |
|------|-----|
| Time | O(n + k), k = 값의 범위 |
| Space | O(k) = O(100001) |
| 장점 | 정렬 없이 O(n)에 가까움 |
| 단점 | 고정 메모리 사용, 값 범위 제한 필요 |

---

## 성능 비교

| n 크기 | 권장 방식 | 이유 |
|--------|-----------|------|
| n < ~5000 | Sorting | 정렬 오버헤드가 작음 |
| n > ~5000 | Frequency | O(n) vs O(n log n) 차이 발생 |
| 값 범위 > 10^6 | Sorting | Frequency 배열이 너무 커짐 |

---

## 추가 최적화 팁

1. **Math.max() 피하기**
   ```java
   // 느림
   max = Math.max(max, sum);

   // 빠름
   if (sum > max) max = sum;
   ```

2. **인라인 증감 피하기**
   ```java
   // 덜 최적화됨
   nums[l++] + nums[r--]

   // 더 최적화됨
   nums[left] + nums[right];
   left++;
   right--;
   ```

---

## 결론

이 문제의 제약 조건 (n <= 10^5, nums[i] <= 10^5)에서는 **Frequency 방식**이 더 빠를 수 있다.
단, 범용성과 메모리 효율을 고려하면 **Sorting 방식**도 충분히 좋은 선택이다.
